function status = correcting_spikes(datafNameIn,spikesfName, ...
                                                datafNameOut, adj_tpoints)

% correcting_spikes
%
%   status = correcting_spikes(datafNameIn,spikesfName,datafNameOut)
%
%   status = correcting_spikes(datafNameIn,spikesfName, ...
%                                                datafNameOut, adj_tpoints)
% 
% Function to correct for bad (slice,timepoint) pairs in an MRI series, by
%   replacing the spiky slice-timepoint with the average intensity of that
%   same slice from a few time-points before & after the bad timepoint.
%   The othere slices for the spiky volume remain un-touched.
%
% Arguments:
% - datafNameIn:  file with the original data.
% - spikesfName:  file with the structure (generated by 'dataQReport') 
%                 containing the ROI name, the number of spikes for that
%                 ROI and the timepoints at which those spikes were detected
%                 (the '*_spikes.mat' file inside the folder where the html
%                 report was saved).
% - datafNameOut: file (for NIfTI image) or folder (for DICOM images) where
%                 to store the corrected data.
% - adj_tpoints:  (optional) number of timepoints before and after the bad
%                 timepoint to be averaged to substitute the bad slice.
%
% Output:  status =
% - 0: successful correction.
% - 1: unknown error.
% - 2: wrong number of arguments.
% - 3: datafNameIn  not found.
% - 4: spikesfName  not found.
% - 5: datafNameOut same as datafNameIn.
% - 6: datafNameOut directory exists as a file.
%
% Dependencies: 
% - If your images are NIfTI, you need to have in your matlab path the
%   directory with the matlab-nifti functions;
% - If your images are DICOM, you need the image toolbox (CNS and NYU's
%   licenses work);
%
% PJV: v.2.0: February 2009

% PJV: v.2.0: February 2009
%   The input arguments have changed, so that it can be run in after
%     running 'dataQReport'.  The algorithm is still the same.
% PJV: v.1.0: April 2006


%% Initial stuff:

status = 1;   % not done yet!

if (nargin<4)
  adj_tpoints = 2;     % number of adjacent time points (for averaging)
  if (nargin<3)
    status = 2;
    fprintf(['\nWrong number of arguments.\n'...
             'Type "help correcting_spikes" for help.\n\n']);
    return
  end
end


%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%   check arguments   %%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%

% data file in:
[pathstrIn, nameIn, extIn] = fileparts(datafNameIn);
datafNameIn = fullfile(pathstrIn, [nameIn extIn]);
if ~exist( datafNameIn, 'file' );
  status = 3;
  fprintf('\nFile not found: %s.\n\n',datafNameIn);
  return
end
%   find type of data file   %
if strcmpi( extIn, '.dcm')
  filetype = 'DICOM';
elseif (strcmpi( extIn, '.nii') || ...
        strcmpi( extIn, '.hdr') || ...
        strcmpi( extIn, '.img') )
  filetype = 'Nifti';
else
  error('Unknown file extension.  The file must be "DICOM" or "Nifti"')
end

% spikes file:
[pathstrSpikes, nameSpikes, extSpikes] = fileparts(spikesfName);
spikesfName = fullfile(pathstrSpikes, [nameSpikes extSpikes]);
if ~exist( spikesfName, 'file' );
  status = 4;
  fprintf('\nFile not found: %s.\n\n',spikesfName);
  return
end

% datafNameOut: 
[pathstrOut, nameOut, extOut] = fileparts(datafNameOut);
datafNameOut = fullfile(pathstrOut, [nameOut extOut]);
switch filetype
  case 'Nifti'
    if exist( datafNameOut, 'file' )==2;
      % warn if file already exists:
      fprintf('\nWarning: File already exists: %s.\n\n', datafNameOut);
      % if datafNameOut is the same as datafNameIn, return an error:
      if strcmp(datafNameOut,datafNameIn)
        status = 5;
        fprintf(['\nOut file cannot be the same as input file.\n',...
          'Run "correcting_spikes" again with a different output name.\n\n']);
        return
      end
    end
  case 'DICOM'    % for DICOM, the datafNameOut should be a directory:
    % warn if datafNameOut has an extension.  We'll create the directory
    %  later, nervertheless:
    if ~isempty(extOut)
      fprintf(['\nWarning: For DICOM files, the output argument should '...
               'be a directory.\n\n'], datafNameOut);
    end
    
    if exist( datafNameOut, 'file' )==7;
      % warn if directory already exists:
      fprintf('\nWarning: Directory already exists: %s.\n\n', datafNameOut);
      % if datafNameOut is the same as directory where datafNameIn is, return an error:
      if strcmp(datafNameOut,datafNameIn)
        status = 5;
        fprintf(['\nOut file cannot be the same as input file.\n',...
          'Run "correcting_spikes" again with a different output name.\n\n']);
        return
      end
    elseif exist( datafNameOut, 'file' )==2;
      status = 6;
      fprintf(['\n%s exists as a file.\n',...
        'Unable to make a directory with the same name.\n\n']);
      return
    end
    
    if ~exist( datafNameOut, 'file' )   % if it doesn't exist ...
      % ... make the directory (using the operating system's call 'mkdir'):
      statement = sprintf('! mkdir %s', datafNameOut );
      eval(statement)
    end
end


%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%   Get data header  %%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%

switch filetype

  case 'DICOM'
    hdr = dicominfo(datafNameIn);
    
    if strcmpi(hdr.InPlanePhaseEncodingDirection, 'ROW')
      % Phase-Encoding dimension: 1 = growing fastest in file (x); 2 = y;
%       PE_dim = 2;
      Ny = hdr.NumberOfPhaseEncodingSteps;
      Nx = 100 * Ny / hdr.PercentPhaseFieldOfView;

      % if PE dir is along 'ROW', the number of rows should be Ny;
      % otherwise, the image is in MOSAIC format.
      if (hdr.Rows~=Nx)
        bMosaic = true;
      else
        bMosaic = false;
      end

    elseif strcmpi(hdr.InPlanePhaseEncodingDirection, 'COL')
      % Phase-Encoding dimension: 1 = growing fastest in file (x); 2 = y;
%       PE_dim = 1;
      Nx = hdr.NumberOfPhaseEncodingSteps;
      Ny = 100 * Nx / hdr.PercentPhaseFieldOfView;

      % if PE dir is along 'COL', the number of columns should be Nx;
      % otherwise, the image is in MOSAIC format.
      if (hdr.Columns~=Ny)
        bMosaic = true;
      else
        bMosaic = false;
      end

    end

    Nz = getNSlices(hdr);           % no. slices

    % structure containing a list of all .dcm files in the same folder as
    % the input data file:
    file_list = dir(fullfile( pathstrIn,['*',extIn] ));

    if bMosaic
      % when MOSAIC format, all slices for a given volume are in 1 file.
      Nt = length(file_list);                 % repetitions
      FoV_col = Ny;       % FoV along horizontal (i.e. how many columns per slice)
      nSl_col = double(hdr.Columns)/FoV_col;   % no. slices in horizontal direction
    else    % no MOSAIC image
      % the file structure in the directory is more complicated: there are
      % Nz * Nt files:
      Nt = floor( length(file_list)/Nz );
    end

  case 'Nifti'
    hdr = niftifile(datafNameIn);
    hdr = fopen(hdr, 'read');

    Nz     = hdr.nz;
    Nx     = hdr.nx;
    Ny     = hdr.ny;
    Nt     = hdr.nt;
    % Phase-Encoding dimension: 1 = growing fastest in file (x); 2 = y;
%     PE_dim = hdr.phase_dim;

end


%%
  %%%%%%%%%%%%%%%%%%%%%%
  %%%   Get spikes   %%%
  %%%%%%%%%%%%%%%%%%%%%%

%%% Get all the pairs (slice,tpoint) which contain a spike:
  
spikes = [];    % to store the pairs.

% load spikefName (it contains a variable called 'peaks')
candidates = load( spikesfName );

nROIs = length(candidates.peaks);    % number of ROIs (normally same as Nz).

% loop through the differnt ROIs (the elements of 'peaks')
for n=1:nROIs
  if candidates.peaks(n).nspk  % if there are any spikes for this ROI
    % store the (slice,tpoint) pairs:
    for i=1:length(candidates.peaks(n).slices)   % loop through slices in this ROI
      for t=1:candidates.peaks(n).nspk
        spikes = [ spikes; [candidates.peaks(n).slices(i), candidates.peaks(n).ts(t)] ];
      end
    end
  end
end

% In case there are repeated instances (if we had overlapping ROIs, for
%   instance)
spikes = unique( spikes, 'rows' );


%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%
  %%%   correct the data   %%%
  %%%%%%%%%%%%%%%%%%%%%%%%%%%%

switch filetype

  case 'Nifti'    %%%   NIfTI images   %%%
    
    % For the case of NIfTI files, we have to write out the whole 4D
    % volume.  So loop through the volumes and, if no spikes, copy them out
    % or, if there are spikes, calculate the correction and write this out.
    
    % open output file for writing:
    hdrOut = niftifile(datafNameOut,hdr);   % base new header on original one
    hdrOut = fopen(hdrOut,'write');
    
    % loop through the volumes:
    for t=1:Nt
      
      % check if there are spikes in this volume
      if isempty( spikes(:,2)==t )    % if no spikes for this volume

        hdr = fseek(hdr, (t-1)*Nx*Ny*Nz, 'bof');
        [hdr,buff] = fread(hdr, Nx*Ny*Nz);  % read the original volume ...
        hdrOut = fwrite(hdrOut, buff);      % ... and copy it out un-touched
    
      else  % if there are spikes, we need to correct the bad slices
        
        % spiky slice numbers for this volume:
        spiky_slices = spikes( spikes(:,2)==t );

        hdr = fseek(hdr, (t-1)*Nx*Ny*Nz, 'bof');
        [hdr,buff] = fread(hdr, Nx*Ny*Nz);  % read the original volume ...
        vol = reshape( buff, Nx, Ny, Nz );  % ... reshape it into 3D array
        
        % loop through the spiky slices:
        for n=1:length(spiky_slices)
          
          zn = spiky_slices(n);   % slice number
          
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %   CORRECTION for NIfTI   %
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
          % adjacent time points (to be used for the average):
          adj_set = [ (t-adj_tpoints):(t-1), (t+1):(t+adj_tpoints) ];
          
          % check for all bad time points corresponding to that slice
          % (including the one we are considering):
          bad_tpoints = spikes( spikes(:,1)==zn , 2 );
          % take the difference between adj_set & bad_tpoints, so that we
          % don't include in the average any other bad timepoint:
          adj_set = setdiff(adj_set, bad_tpoints);
          % only points bigger than 0 and smaller than the n timepoints
          adj_set = adj_set(find( (adj_set>0)&(adj_set<=Nt) ));
          
          % read that slice, for all tpoints in adj_set:
          adj_data = zeros(Nx,Ny,length(adj_set));
          for i=1:length(adj_set)
            offset = ( adj_set(i) -1)*Nx*Ny*Nz + ...   % skip adj_set(i)-1 vols
                               (zn-1)*Nx*Ny;           % and zn-1 slices
            hdr = fseek(hdr, offset, 'bof');
            [hdr, buff] = fread(hdr, Nx*Ny);    % get 1 slice worth of data
            adj_data(:,:,i) = reshape(buff,Nx,Ny);
          end
          vol(:,:,zn) = mean( adj_data, 3 );
          
        end   % loop through spiky slices
        
      end     % of checking whether there are any spikes for this volume

      hdrOut = fwrite(hdrOut, vol(:), Nx*Ny*Nz);      % write out the new volume

    end       % loop through volumes ('t')
  
  case 'DICOM'    %%%   DICOM images   %%%

    %%% In this case, we only save the volumes (in mosaic) corresponding to
    %%%   the corrected time-points.  For the other volumes, we copy them
    %%%   stright away.
    
    if bMosaic    % 1 full volume per DICOM file
      
      %%%   MOSAIC   %%%
      
      % loop through the volumes:
      for t=1:Nt

        % check if there are spikes in this volume
        if isempty( spikes(:,2)==t )    % if no spikes for this volume ...

          % ... copy DICOM file (using the operating system's call 'cp'):
          statement = sprintf( '! cp %s %s', ...
            fullfile(pathstrIn,    file_list(t).name), ...
            fullfile(datafNameOut, file_list(t).name) );
          eval(statement)

        else  % if there are spikes, we need to correct the bad slices

          % spiky slice numbers for this volume:
          spiky_slices = spikes( spikes(:,2)==t );

          % we read the original MOSAIC volume:
          mosVol = dicomread( fullfile(pathstrIn, file_list(t).name) );

          % loop through the spiky slices:
          for n=1:length(spiky_slices)

            zn = spiky_slices(n);   % slice number

          
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %   CORRECTION for DICOM mosaic   %
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
            % adjacent time points (to be used for the average):
            adj_set = [ (t-adj_tpoints):(t-1), (t+1):(t+adj_tpoints) ];

            % check for all bad time points corresponding to that slice
            % (including the one we are considering):
            bad_ts_thisSlice = spikes( spikes(:,1)==zn , 2 );
            % take the difference between adj_set & bad_tpoints, so that we
            % don't include in the average any other bad timepoint:
            adj_set = setdiff(adj_set, bad_ts_thisSlice);
            % only points bigger than 0 and smaller than the n timepoints
            adj_set = adj_set(find( (adj_set>0)&(adj_set<=Nt) ));

            % read that DICOM volume, for all tpoints in adj_set:
            adj_data = zeros(Nx,Ny,length(adj_set));
            for i=1:length(adj_set)
              % read the volume for the adjacent timepoint:
              adj_vol = dicomread( fullfile(pathstrIn,file_list(adj_set(i)).name) );
              % save the data corresponding to the defective slice:
              adj_data(:,:,i) = adj_vol( floor((zn-1)/nSl_col)*FoV_col+(1:FoV_col),...
                                            mod(zn-1, nSl_col)*FoV_col+(1:FoV_col) );
            
            end
            mosVol( floor((zn-1)/nSl_col)*FoV_col+(1:FoV_col), ...
                       mod(zn-1, nSl_col)*FoV_col+(1:FoV_col) ) = mean( adj_data, 3 );
          
          end   % loop through spiky slices

          % Save it into a DICOM file, for that timepoint:
          thisVol_fNameOut = fullfile( datafNameOut, file_list(t).name );
          hdr = dicominfo( thisVol_fNameOut );
          dicomwrite(uint16(mosVol), thisVol_fNameOut, hdr, 'WritePrivate', true);

        end    % of the 'else': if there are spikes.
      
      end      % of looping through volumes

    else  % if no mosaic, but 1 slice per DICOM file
      
      %%%   non-MOSAIC   %%%
      
      % loop through the volumes:
      for t=1:Nt

        % check if there are spikes in this volume
        if ~any( spikes(:,2)==t )    % if no spikes for this volume ...

          % ... copy all DICOM files for this volume:
          %     (using the operating system's call 'cp'):
          for zn = 1:Nz
            nFile = (t-1)*Nz + zn;
            statement = sprintf( '! cp %s %s', ...
              fullfile(pathstrIn,    file_list(nFile).name), ...
              fullfile(datafNameOut, file_list(nFile).name) );
            eval(statement)
          end

        else  % if there are spikes, we need to correct the bad slices

          % spiky slice numbers for this volume:
          spiky_slices = spikes( spikes(:,2)==t );
          
          % loop through the slices for this volume:
          for zn = 1:Nz
            
            % check if this slice is spiky:
            if isempty( spiky_slices==zn )    % if no spike for this zn ...
              
              % ... copy DICOM file (using 'cp'):
              nFile = (t-1)*Nz + zn;
              statement = sprintf( '! cp %s %s', ...
                fullfile(pathstrIn,    file_list(nFile).name), ...
                fullfile(datafNameOut, file_list(nFile).name) );
              eval(statement)

            else      % if it is one of the spiky slices in this volume:

                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
                %   CORRECTION for DICOM non-mosaic  %
                %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        
              % adjacent time points (to be used for the average):
              adj_set = [ (t-adj_tpoints):(t-1), (t+1):(t+adj_tpoints) ];

              % check for all bad time points corresponding to that slice
              % (including the one we are considering):
              bad_ts_thisSlice = spikes( spikes(:,1)==zn , 2 );
              % take the difference between adj_set & bad_tpoints, so that we
              % don't include in the average any other bad timepoint:
              adj_set = setdiff(adj_set, bad_ts_thisSlice);
              % only points bigger than 0 and smaller than the n timepoints
              adj_set = adj_set(find( (adj_set>0)&(adj_set<=Nt) ));

              % read that DICOM slice, for all tpoints in adj_set:
              adj_data = zeros(Nx,Ny,length(adj_set));
              for i=1:length(adj_set)
                % read the volume for the adjacent timepoint:
                nFile = (adj_set(i)-1)*Nz + zn;
%                 adj_slice = dicomread( fullfile(pathstrIn,file_list(nFile).name) );
%                 % save the data corresponding to the defective slice:
%                 adj_data(:,:,i) = adj_slice;
                adj_data(:,:,i) = dicomread( fullfile(pathstrIn,file_list(nFile).name) );
              end
              % Save it into a DICOM file, for that timepoint:
              nFile = (t-1)*Nz + zn;
              thisVol_fNameOut = fullfile( datafNameOut, file_list(nFile).name );
              hdr = dicominfo( thisVol_fNameOut );
              dicomwrite( uint16(mean(adj_data,3)), thisVol_fNameOut, hdr, 'WritePrivate', true);
              
            end   % of else (if there is a spike in this slice)
            
          end     % loop through spiky slices

        end       % of the 'else': if there are spikes for this volume.
      
      end         % of looping through volumes
    
    end           % of 'else': no mosaic

end               % of 'case' switching

%%

status = 0;     % if you made it to here, we were successful
